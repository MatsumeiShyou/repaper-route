/**
 * @typedef {import('../types').Driver} Driver
 * @typedef {import('../types').Job} Job
 * @typedef {import('../types').Split} Split
 */
import { useState, useEffect, useCallback, useRef } from 'react';
import { supabase } from '../../../lib/supabase/client';
import { useMasterData } from './useMasterData';
import { generateJobColorMap } from '../../core/config/theme';
import { timeToMinutes } from '../logic/timeUtils';

export const useBoardData = (currentUserId, currentDateKey) => {
    // --- Master Data ---
    const { drivers: masterDrivers, vehicles, customers, items, customerItemDefaults, isLoading: isMasterLoading } = useMasterData();

    // --- State ---
    const [drivers, setDrivers] = useState([]);
    const [jobs, setJobs] = useState([]);
    const [pendingJobs, setPendingJobs] = useState([]);
    const [splits, setSplits] = useState([]);

    // Supabase / Persistence State
    const [isDataLoaded, setIsDataLoaded] = useState(false);
    const [isOffline, setIsOffline] = useState(false);
    const [isSyncing, setIsSyncing] = useState(false);
    const [localUpdatedAt, setLocalUpdatedAt] = useState(Date.now());

    // Lock & Permission State
    const [editMode, setEditMode] = useState(false);
    const [lockedBy, setLockedBy] = useState(null);
    const [canEditBoard, setCanEditBoard] = useState(false);

    // History State
    const [history, setHistory] = useState({ past: [], future: [] });

    // Notification State (Check if better managed here or in UI)
    const [notification, setNotification] = useState(null);

    const showNotification = useCallback((message, type = 'success') => {
        setNotification({ message, type });
        setTimeout(() => setNotification(null), 3000);
    }, []);

    // ----------------------------------------
    // 1. Logic Helpers
    // ----------------------------------------
    const recordHistory = useCallback(() => {
        setHistory(prev => ({
            past: [...prev.past, { jobs, pendingJobs, splits, drivers }],
            future: []
        }));
    }, [jobs, pendingJobs, splits, drivers]);

    const undo = useCallback(() => {
        setHistory(prev => {
            if (prev.past.length === 0) return prev;
            const previous = prev.past[prev.past.length - 1];
            const newPast = prev.past.slice(0, -1);
            const newFuture = [{ jobs, pendingJobs, splits, drivers }, ...prev.future];

            setJobs(previous.jobs);
            setPendingJobs(previous.pendingJobs);
            setSplits(previous.splits);
            setDrivers(previous.drivers);

            return { past: newPast, future: newFuture };
        });
    }, [jobs, pendingJobs, splits, drivers]);

    const redo = useCallback(() => {
        setHistory(prev => {
            if (prev.future.length === 0) return prev;
            const next = prev.future[0];
            const newFuture = prev.future.slice(1);
            const newPast = [...prev.past, { jobs, pendingJobs, splits, drivers }];

            setJobs(next.jobs);
            setPendingJobs(next.pendingJobs);
            setSplits(next.splits);
            setDrivers(next.drivers);

            return { past: newPast, future: newFuture };
        });
    }, [jobs, pendingJobs, splits, drivers]);

    // ----------------------------------------
    // 2. Initialization & Data Loading
    // ----------------------------------------
    const generateInitialData = useCallback(() => {
        // Empty init, waiting for master data
        setJobs([]);
        setPendingJobs([]);
        setSplits([]);
        setDrivers([]);
    }, []);

    useEffect(() => {
        const initializeData = async () => {
            setIsSyncing(true);
            try {
                // 1. Fetch Board Data
                const { data, error } = await supabase
                    .from('routes')
                    .select('*')
                    .eq('date', currentDateKey)
                    .single();

                if (error && error.code !== 'PGRST116') throw error; // PGRST116 is "No rows found"

                if (data) {
                    if (data.jobs) setJobs(data.jobs);
                    if (data.drivers && data.drivers.length > 0) setDrivers(data.drivers);
                    if (data.splits) setSplits(data.splits);
                    if (data.pending) setPendingJobs(data.pending);
                    setLocalUpdatedAt(data.updated_at);
                    setIsOffline(false);
                } else {
                    generateInitialData();
                }

                // 2. Fetch User Permissions
                if (currentUserId) {
                    const { data: userProfile, error: profileError } = await supabase
                        .from('profiles')
                        .select('can_edit_board')
                        .eq('id', currentUserId)
                        .single();

                    if (!profileError && userProfile) {
                        setCanEditBoard(userProfile.can_edit_board || false);
                    } else {
                        console.warn("Permission fetch failed or no profile", profileError);
                        setCanEditBoard(false);
                    }
                }
            } catch (err) {
                console.warn("Supabase load failed, falling back to local storage.", err);
                setIsOffline(true);
                // LocalStorage Fallback
                const storedJobs = localStorage.getItem('repaper_route_jobs');
                const storedDrivers = localStorage.getItem('repaper_route_drivers');
                const storedSplits = localStorage.getItem('repaper_route_splits');
                const storedPending = localStorage.getItem('repaper_route_pending');

                if (storedJobs) setJobs(JSON.parse(storedJobs));
                if (storedDrivers) setDrivers(JSON.parse(storedDrivers));
                if (storedSplits) setSplits(JSON.parse(storedSplits));
                if (storedPending) setPendingJobs(JSON.parse(storedPending));
            } finally {
                setIsDataLoaded(true);
                setIsSyncing(false);
            }
        };

        initializeData();
    }, [currentDateKey, currentUserId, generateInitialData]);

    // Master Data Sync - Phase 7: Course-Based Initialization
    // We no longer sync columns directly from master drivers.
    // Instead, we initialize A-E courses if the board is empty.
    useEffect(() => {
        if (!isDataLoaded) return;

        setDrivers(prev => {
            if (prev.length === 0) {
                // Initialize Default Courses A-E
                return ['A', 'B', 'C', 'D', 'E'].map(courseName => ({
                    id: `course_${courseName}`,
                    name: `${courseName}コース`,
                    driverName: '未割当',
                    currentVehicle: '未定',
                    course: courseName, // Keep for backward compatibility/reference
                    color: 'bg-gray-50 border-gray-200'
                }));
            }
            return prev;
        });
    }, [isDataLoaded]);

    // ----------------------------------------
    // 3. Lock Management
    // ----------------------------------------
    const requestEditLock = useCallback(async () => {
        if (!canEditBoard) {
            showNotification("編集権限がありません（閲覧専用）", "error");
            return;
        }

        const currentTime = new Date().toISOString();
        const TIMEOUT_MS = 15 * 60 * 1000;

        try {
            const { data: route } = await supabase
                .from('routes')
                .select('edit_locked_by, edit_locked_at, last_activity_at')
                .eq('date', currentDateKey)
                .maybeSingle();

            const isLockExpired = route?.last_activity_at &&
                (Date.now() - new Date(route.last_activity_at).getTime()) > TIMEOUT_MS;

            if (!route?.edit_locked_by || isLockExpired || route.edit_locked_by === currentUserId) {
                const { error } = await supabase.from('routes').upsert({
                    date: currentDateKey,
                    edit_locked_by: currentUserId,
                    edit_locked_at: currentTime,
                    last_activity_at: currentTime,
                    updated_at: currentTime
                }, { onConflict: 'date' }); // Upsert just lock fields? No, need to be careful not to overwrite data with empty if row didn't exist.
                // Actually BoardCanvas logic fetched full data then upserted everything. 
                // Detailed check: The logic in BoardCanvas was:
                // upsert({ ...jobs, ...drivers, ...splits ... }) 
                // We should probably just update lock fields if data exists, or upsert full if new.

                // Simplified: Just update/upsert lock fields? 
                // NOTE: Supabase upsert requires all non-nullable fields if row is new. 
                // Since this uses `upsert`, it might overwrite data if we don't include it.
                // BUT BoardCanvas.jsx line 263 included `jobs: route?.jobs || []` etc.
                // We should replicate that safety.

                // For simplicity in this hook extraction, let's assume we pass current state or fetch it.
                // Better approach: Update only lock columns if row exists.

                let updateData = {
                    date: currentDateKey,
                    edit_locked_by: currentUserId,
                    edit_locked_at: currentTime,
                    last_activity_at: currentTime,
                    updated_at: currentTime
                };

                if (!route) {
                    // New row: include empty data structure
                    updateData = { ...updateData, jobs: [], drivers: [], splits: [], pending: [] };
                }

                const { error } = await supabase.from('routes').upsert(updateData, { onConflict: 'date' });

                if (!error) {
                    setEditMode(true);
                    setLockedBy(null);
                    showNotification("編集モードで開きました", "success");
                }
            } else {
                setEditMode(false);
                setLockedBy(route.edit_locked_by);
                showNotification(`${route.edit_locked_by}が編集中です`, "info");
            }
        } catch (e) {
            console.error("Lock error:", e);
        }
    }, [currentUserId, currentDateKey, canEditBoard, showNotification]);

    const releaseEditLock = useCallback(async () => {
        if (!editMode) return;
        try {
            await supabase.from('routes').update({
                edit_locked_by: null,
                edit_locked_at: null,
                last_activity_at: null
            }).eq('date', currentDateKey).eq('edit_locked_by', currentUserId);

            setEditMode(false);
            setLockedBy(null);
            showNotification("編集権を解放しました", "success");
        } catch (e) {
            console.error("Release lock error:", e);
        }
    }, [editMode, currentDateKey, currentUserId, showNotification]);

    // Auto-Heartbeat
    useEffect(() => {
        if (!editMode) return;
        const interval = setInterval(async () => {
            await supabase.from('routes').update({
                last_activity_at: new Date().toISOString()
            }).eq('date', currentDateKey).eq('edit_locked_by', currentUserId);
        }, 60000);
        return () => clearInterval(interval);
    }, [editMode, currentDateKey, currentUserId]);

    // Initial Lock Request
    const lockRequestedRef = useRef(false);
    useEffect(() => {
        if (isDataLoaded && !lockRequestedRef.current) {
            lockRequestedRef.current = true;
            requestEditLock();
        }
    }, [isDataLoaded, requestEditLock]);

    // ----------------------------------------
    // 4. Persistence & Real-time
    // ----------------------------------------
    // LocalStorage Sync
    useEffect(() => {
        if (!isDataLoaded) return;
        localStorage.setItem('repaper_route_jobs', JSON.stringify(jobs));
        localStorage.setItem('repaper_route_drivers', JSON.stringify(drivers));
        localStorage.setItem('repaper_route_splits', JSON.stringify(splits));
        localStorage.setItem('repaper_route_pending', JSON.stringify(pendingJobs));
    }, [jobs, drivers, splits, pendingJobs, isDataLoaded]);

    // Manual Save
    const handleSave = async () => {
        setIsSyncing(true);
        try {
            const { data: latest } = await supabase.from('routes').select('updated_at').eq('date', currentDateKey).maybeSingle();

            if (latest && localUpdatedAt && latest.updated_at !== localUpdatedAt) {
                showNotification("他ユーザーによる変更があります。リロードします", "error");
                setTimeout(() => window.location.reload(), 1500);
                return;
            }

            const newTimestamp = new Date().toISOString();
            await supabase.from('routes').upsert({
                date: currentDateKey,
                jobs, drivers, splits, pending: pendingJobs,
                updated_at: newTimestamp
            }, { onConflict: 'date' });

            setLocalUpdatedAt(newTimestamp);
            setIsOffline(false);
            showNotification("保存しました", "success");
        } catch (e) {
            console.error("Save error:", e);
            setIsOffline(true);
            showNotification("保存失敗 (オフライン)", "error");
        } finally {
            setIsSyncing(false);
        }
    };

    // Real-time Subscription
    useEffect(() => {
        const channel = supabase.channel('board_changes')
            .on('postgres_changes', { event: 'UPDATE', schema: 'public', table: 'routes', filter: `date=eq.${currentDateKey}` }, (payload) => {
                const newData = payload.new;

                // Lock Logic
                if (newData.edit_locked_by && newData.edit_locked_by !== currentUserId) {
                    setEditMode(false);
                    setLockedBy(newData.edit_locked_by);
                    showNotification(`${newData.edit_locked_by}が編集中です`, "warning");
                }
                if (!newData.edit_locked_by && !editMode && lockedBy) {
                    setLockedBy(null);
                    showNotification("編集可能になりました", "success");
                }

                // Data Internalize (ReadOnly Mode) or Conflict Detect (Edit Mode)
                if (newData.updated_at) {
                    if (editMode && localUpdatedAt && newData.updated_at !== localUpdatedAt) {
                        showNotification("競合を検知しました。リロードします", "error");
                        setTimeout(() => window.location.reload(), 2000);
                    } else if (!editMode) {
                        // Auto-update in read-only
                        if (newData.jobs) setJobs(newData.jobs);
                        if (newData.drivers) setDrivers(newData.drivers);
                        if (newData.splits) setSplits(newData.splits);
                        if (newData.pending) setPendingJobs(newData.pending);
                        setLocalUpdatedAt(newData.updated_at);
                    }
                }
            })
            .subscribe();

        return () => { supabase.removeChannel(channel); };
    }, [currentDateKey, currentUserId, editMode, lockedBy, localUpdatedAt, showNotification]);



    // ----------------------------------------
    // 4. Column Management (Phase 7)
    // ----------------------------------------
    const addColumn = useCallback(() => {
        if (!editMode) return;
        const newCourseName = String.fromCharCode(65 + drivers.length); // F, G, H...
        const newColumn = {
            id: `course_${newCourseName}_${Date.now()}`,
            name: `${newCourseName}コース`,
            driverName: '未割当',
            currentVehicle: '未定',
            course: newCourseName,
            color: 'bg-gray-50 border-gray-200'
        };
        setDrivers(prev => [...prev, newColumn]);
        recordHistory();
    }, [editMode, drivers, recordHistory]);

    const deleteColumn = useCallback((columnId) => {
        if (!editMode) return;
        // Check if jobs exist
        if (jobs.some(j => j.driverId === columnId)) {
            showNotification('案件が残っているコースは削除できません', 'error');
            return;
        }
        setDrivers(prev => prev.filter(d => d.id !== columnId));
        recordHistory();
    }, [editMode, jobs, recordHistory, showNotification]);

    return {
        // Master Data
        masterDrivers, vehicles, customers, items, customerItemDefaults,

        // State
        drivers, setDrivers,
        jobs, setJobs,
        pendingJobs, setPendingJobs,
        splits, setSplits,

        // Status
        isDataLoaded, isOffline, isSyncing,
        editMode, lockedBy, canEditBoard,
        notification, showNotification,

        // Actions
        requestEditLock, releaseEditLock, handleSave,

        // History
        history, recordHistory, undo, redo,

        // Column Management
        addColumn, deleteColumn
    };
};
